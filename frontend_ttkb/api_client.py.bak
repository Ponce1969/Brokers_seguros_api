"""
Cliente API para comunicación con el backend

Este cliente está diseñado para ser simple, directo y alineado
con los endpoints del backend. Utiliza la biblioteca requests
para realizar peticiones HTTP.
"""

import requests
import logging
from typing import Dict, List, Any, Optional, Union, Tuple
from urllib.parse import urljoin
from . import config

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class APIClient:
    """
    Cliente API simple para comunicarse con el backend.
    
    Esta clase proporciona métodos para interactuar con el backend
    de forma directa y sencilla, sin abstracciones innecesarias.
    """
    
    def __init__(self):
        """
        Inicializa el cliente API con la URL base configurada.
        """
        self.base_url = config.API_URL
        self.token = None
        self.token_type = None
        self.session = requests.Session()
        logger.info(f"Cliente API inicializado con URL base: {self.base_url}")
    
    def set_token(self, token: str, token_type: str = "bearer") -> None:
        """
        Establece el token de autenticación para las peticiones.
        
        Args:
            token: El token JWT para autenticación.
            token_type: El tipo de token (por defecto 'bearer').
        """
        self.token = token
        self.token_type = token_type
        # Configurar el token en los headers para todas las peticiones futuras
        self.session.headers.update({"Authorization": f"{token_type.capitalize()} {token}"})
        logger.info("Token de autenticación establecido")
    
    def clear_token(self) -> None:
        """
        Elimina el token de autenticación.
        """
        self.token = None
        self.token_type = None
        if "Authorization" in self.session.headers:
            del self.session.headers["Authorization"]
        logger.info("Token de autenticación eliminado")
    
    def _get_full_url(self, endpoint: str) -> str:
        """
        Construye la URL completa para un endpoint.
        
        Args:
            endpoint: El endpoint relativo (sin la URL base).
            
        Returns:
            La URL completa para el endpoint.
        """
        # Asegurarse de que el endpoint no comience con '/'
        if endpoint.startswith("/"):
            endpoint = endpoint[1:]
        return urljoin(self.base_url, endpoint)
    
    def _handle_response(self, response: requests.Response) -> Tuple[bool, Any]:
        """
        Procesa la respuesta de la API y maneja posibles errores.
        
        Args:
            response: La respuesta HTTP recibida.
            
        Returns:
            Una tupla (exito, datos), donde exito es un booleano que indica
            si la petición fue exitosa, y datos contiene los datos de la respuesta
            o un mensaje de error.
        """
        try:
            # Verificar si la petición fue exitosa (código 2xx)
            if response.ok:
                # Intentar parsear la respuesta como JSON
                try:
                    data = response.json()
                    return True, data
                except ValueError:
                    # Si no es JSON, devolver el texto de la respuesta
                    return True, response.text
            else:
                # Manejar errores comunes
                if response.status_code == 401:
                    logger.error(f"Error de autenticación: {response.text}")
                    return False, config.MSG_ERROR_AUTENTICACION
                elif response.status_code == 403:
                    logger.error(f"Error de permisos: {response.text}")
                    return False, config.MSG_ERROR_PERMISOS
                elif response.status_code == 404:
                    logger.error(f"Recurso no encontrado: {response.text}")
                    return False, f"El recurso solicitado no existe: {response.url}"
                else:
                    # Intentar obtener detalles del error desde JSON
                    try:
                        error_data = response.json()
                        error_msg = error_data.get("detail", str(error_data))
                    except ValueError:
                        error_msg = response.text or f"Error {response.status_code}"
                    
                    logger.error(f"Error en petición ({response.status_code}): {error_msg}")
                    return False, error_msg
        except requests.exceptions.RequestException as e:
            logger.error(f"Error de conexión: {str(e)}")
            return False, config.MSG_ERROR_CONEXION
    
    def login(self, username: str, password: str) -> dict:
        """
        Realiza la autenticación con el backend.
        
        Args:
            username: El correo electrónico del usuario.
            password: La contraseña del usuario.
            
        Returns:
            Un diccionario con el token de acceso y su tipo si el login fue exitoso.
            
        Raises:
            Exception: Si hay algún error en la autenticación.
        """
        try:
            url = self._get_full_url(config.ENDPOINT_LOGIN)
            logger.info(f"Intentando login para usuario: {username}")
            
            # Datos de la petición de login
            data = {
                "username": username,
                "password": password
            }
            
            # Realizar la petición POST
            response = self.session.post(
                url, 
                data=data,
                timeout=config.HTTP_TIMEOUT
            )
            
            success, result = self._handle_response(response)
            if success:
                # Si el login fue exitoso, extraer el token
                token = result.get("access_token")
                token_type = result.get("token_type", "bearer")
                if token:
                    # No establecemos el token aquí, lo dejamos para que lo haga
                    # el llamador si así lo decide
                    logger.info(f"Login exitoso para {username}")
                    return result
                else:
                    logger.error("Login exitoso pero no se recibió token")
                    raise Exception("Error: No se recibió token de acceso")
            else:
                logger.error(f"Error en login: {result}")
                raise Exception(str(result))
        except Exception as e:
            logger.error(f"Error inesperado en login: {str(e)}")
            raise Exception(f"Error de autenticación: {str(e)}")
    
    def get_clientes(self, role: str = None) -> List[dict]:
        """
        Obtiene la lista de clientes del backend.
        
        Args:
            role: El rol del usuario actual ('admin' o 'corredor').
                 Si es admin, se asegura de obtener clientes reales.
                 
        Returns:
            Una lista de diccionarios con los datos de los clientes.
            
        Raises:
            Exception: Si hay algún error en la petición.
        """
        try:
            url = self._get_full_url(config.ENDPOINT_CLIENTES)
            logger.info(f"Obteniendo lista de clientes para rol: {role}")
            
            # SOLUCIÓN AL PROBLEMA DE INCONSISTENCIA:
            # Sabemos que el endpoint se comporta diferente según la autenticación
            if role == 'admin':
                # Para administradores, necesitamos asegurar que obtenemos clientes reales
                # La solución es añadir un parámetro especial para indicarle al backend
                # que queremos los clientes reales, no los corredores
                url = f"{url}?real_clients=true"
                logger.info("Usuario administrador: solicitando clientes reales")
            
            response = self.session.get(
                url,
                timeout=config.HTTP_TIMEOUT
            )
            
            success, result = self._handle_response(response)
            if success:
                # Validar que el resultado es una lista
                if isinstance(result, list):
                    # Filtrar para asegurarnos de tener solo clientes reales
                    # Este es un paso adicional para manejar la inconsistencia
                    filtered_clients = []
                    for client in result:
                        # Verificar si parece un corredor (tiene campos específicos)
                        if role == 'admin' and client.get('is_superuser') is not None:
                            # Esto parece un corredor, no un cliente real
                            logger.debug(f"Filtrando corredor: {client.get('email')}")
                            continue
                        filtered_clients.append(client)
                    
                    logger.info(f"Se obtuvieron {len(filtered_clients)} clientes reales")
                    return filtered_clients
                else:
                    logger.warning("La respuesta no es una lista de clientes")
                    if isinstance(result, dict) and 'items' in result:
                        # Algunos APIs devuelven {items: [...], total: X}
                        return result['items']
                    elif isinstance(result, dict):
                        result = [result]
                    # Si no podemos convertirlo, devolver lista vacía
                    logger.error("No se pudo convertir la respuesta a lista de clientes")
                    return []
            else:
                logger.error(f"Error al obtener clientes: {result}")
                raise Exception(str(result))
        except Exception as e:
            logger.error(f"Error inesperado al obtener información del usuario: {str(e)}")
            raise Exception(f"Error al obtener información del usuario: {str(e)}")

    def get_usuario(self, usuario_id: str) -> dict:
        """
        Obtiene los datos de un usuario específico.
        
        Args:
            usuario_id: El ID del usuario a obtener.
            
        Returns:
            Un diccionario con la información del usuario.
            
        Raises:
            Exception: Si hay algún error en la petición.
                url,
                timeout=config.HTTP_TIMEOUT
            )
            
            return self._handle_response(response)
        except Exception as e:
            logger.error(f"Error inesperado al obtener cliente: {str(e)}")
            return False, f"Error inesperado: {str(e)}"
    
    def create_cliente(self, data: dict) -> Tuple[bool, dict]:
        """
        Crea un nuevo cliente.
        
        Args:
            data: Datos del cliente a crear.
            
        Returns:
            Una tupla (exito, datos), donde exito es un booleano que indica
            si la peticiu00f3n fue exitosa, y datos contiene los datos del cliente creado
            o un mensaje de error.
        """
        try:
            url = self._get_full_url(config.ENDPOINT_CLIENTES)
            logger.info(f"Creando nuevo cliente: {data.get('nombres', '')} {data.get('apellidos', '')}")
            
            response = self.session.post(
                url,
                json=data,
                timeout=config.HTTP_TIMEOUT
            )
            
            return self._handle_response(response)
        except Exception as e:
            logger.error(f"Error inesperado al crear cliente: {str(e)}")
            return False, f"Error inesperado: {str(e)}"
    
    def update_cliente(self, cliente_id: str, data: dict) -> Tuple[bool, dict]:
        """
        Actualiza los datos de un cliente existente.
        
        Args:
            cliente_id: El ID del cliente a actualizar.
            data: Nuevos datos del cliente.
            
        Returns:
            Una tupla (exito, datos), donde exito es un booleano que indica
            si la peticiu00f3n fue exitosa, y datos contiene los datos actualizados
            o un mensaje de error.
        """
        try:
            url = self._get_full_url(f"{config.ENDPOINT_CLIENTES}/{cliente_id}")
            logger.info(f"Actualizando cliente con ID: {cliente_id}")
            
            response = self.session.put(
                url,
                json=data,
                timeout=config.HTTP_TIMEOUT
            )
            
            return self._handle_response(response)
        except Exception as e:
            logger.error(f"Error inesperado al actualizar cliente: {str(e)}")
            return False, f"Error inesperado: {str(e)}"
    
    def delete_cliente(self, cliente_id: str) -> Tuple[bool, Any]:
        """
        Elimina un cliente existente.
        
        Args:
            cliente_id: El ID del cliente a eliminar.
            
        Returns:
            Una tupla (exito, datos), donde exito es un booleano que indica
            si la peticiu00f3n fue exitosa, y datos contiene la respuesta del servidor
            o un mensaje de error.
        """
        try:
            url = self._get_full_url(f"{config.ENDPOINT_CLIENTES}/{cliente_id}")
            logger.info(f"Eliminando cliente con ID: {cliente_id}")
            
            response = self.session.delete(
                url,
                timeout=config.HTTP_TIMEOUT
            )
            
            return self._handle_response(response)
        except Exception as e:
            logger.error(f"Error inesperado al eliminar cliente: {str(e)}")
            return False, f"Error inesperado: {str(e)}"
    
    # Similares mu00e9todos para corredores...
    
    def get_corredores(self) -> Tuple[bool, List[dict]]:
        """
        Obtiene la lista de corredores.
        
        Returns:
            Una tupla (exito, datos), donde exito es un booleano que indica
            si la peticiu00f3n fue exitosa, y datos contiene la lista de corredores
            o un mensaje de error.
        """
        try:
            url = self._get_full_url(config.ENDPOINT_CORREDORES)
            logger.info("Obteniendo lista de corredores")
            
            response = self.session.get(
                url,
                timeout=config.HTTP_TIMEOUT
            )
            
            success, result = self._handle_response(response)
            if success and not isinstance(result, list):
                if isinstance(result, dict):
                    result = [result]
                else:
                    result = []
            
            return success, result
        except Exception as e:
            logger.error(f"Error inesperado al obtener corredores: {str(e)}")
            return False, f"Error inesperado: {str(e)}"
